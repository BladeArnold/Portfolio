//**************************************************************************
 
// Replace with appropriate header comment......

//**************************************************************************
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include "lexer.h"
#include "parser.h"
 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex
int count = 1;
// Which tree level are we currently in?  
static int level = 0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
set<string> symbolTable; // Symbol Table
extern set<string> symbolTable;
set<string>::iterator it;

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);
bool first_of_block(void);
bool first_of_statement(void);

bool first_of_express(void);
bool first_of_simpleexpress(void);
bool first_of_term(void);
bool first_of_factor(void);

bool first_of_assgin(void);
bool first_of_compound(void);
bool first_of_if(void);
bool first_of_while(void);
bool first_of_read(void);
bool first_of_write(void);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
void program() 
{
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    if (nextToken == TOK_PROGRAM) // looks for the program token and outputs and grabs next word
    {
      output("PROGRAM");
      nextToken = yylex();
    }
    
    cout << psp() << "enter <program>" << endl; // lets us know when we enter program and adds a level to output
    ++level;

    
    while (first_of_program()) 
    {
    if (nextToken == TOK_IDENT)  // looks for the iden token and outputs and grabs next word
    {
      output("IDENTIFIER");
      nextToken = yylex();
    }

    if (nextToken == TOK_SEMICOLON) // looks for the semicolon token and outputs and grabs next word
    {
      if (nextToken != TOK_SEMICOLON)
      {
        throw "14: ';' expected";
      }

      output("SEMICOLON");
      nextToken = yylex();
    } 

    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("BLOCK");
      block();
      break;
    }

    if (nextToken == TOK_VAR) // looks for the VAR token and outputs and grabs next word
    {
      output("BLOCK");
      nextToken = yylex();
      block();
      break;
    }

    else 
    {
      throw "2: identifier expected";
    }
    
    }
    
    

    --level;
    cout << psp() << "exit <program>" << endl; // lets us know when we exit the program 
    
}

void block()
{
  cout << psp() << "enter <block>" << endl; // lets us know when we enter block and adds a level
  level++;

  string text1; // for output
  string text2; // for output
  

    while (nextToken != TOK_BEGIN)
    {
      if (nextToken == TOK_IDENT) // looks for the iden in block and outputs it and continues down the list
      {

        text1 = strdup(yytext);
        output("IDENTIFIER");
        nextToken = yylex();
      }

      if (nextToken == TOK_COLON) // looks for the colon token and outputs and grabs next word
      {
        if (nextToken != TOK_COLON)
        {
          throw "5: ':' colon expected";
        }

        output("COLON");
        nextToken = yylex();
      }

      if (nextToken == TOK_REAL) // looks for the real token and outputs and grabs next word
      {
        if (nextToken != TOK_REAL)
        {
          throw "10: in type";
        }

        output("TYPE");
        text2 = strdup(yytext);
        nextToken = yylex(); 
      }

      if (nextToken == TOK_INTEGER) // looks for the integer token and outputs and grabs next word
      {
        if (nextToken != TOK_INTEGER)
        {
          throw "10: in type";
        }

        output("TYPE");
        text2 = strdup(yytext);
        nextToken = yylex();
      }

      if (nextToken == TOK_SEMICOLON) // looks for the semicolon token, outputs the name and type, then inserts variable, then grabs next
      {
        if (nextToken != TOK_SEMICOLON)
        {
          throw "14: ';' expected";
        }

        output("SEMICOLON");
        cout << psp() << "-- idName: |" << text1 << "| idType: |" << text2 << "| --" << endl;

        if (symbolTable.find(text1) != symbolTable.end())
        {
            throw "101: identifier declared twice";
        }

        symbolTable.insert(text1);
        nextToken = yylex();
      }
      else
      {
        block();
        break;
      }
      
    }

    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }
      output("BEGIN");
      nextToken = yylex();
      compound();
    } 

    level--;
    cout << psp() << "exit <block>" << endl; // lets us know when we leave block

  
}



void assignment() // for assignment statment
{
  cout << psp() << "enter <assignment>" << endl; // lets us know when we enter assignment
  level++;

  if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
  {
    output("IDENTIFIER");
    cout << psp() << yytext << endl;
    nextToken = yylex();
  }

  if (nextToken == TOK_ASSIGN) // looks for the assign token and outputs and grabs next word
  {
    if (nextToken != TOK_ASSIGN)
    {
      throw "17: ':=' expected";
    }

    output("ASSIGN");
    nextToken = yylex();
  }

  if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
  {
    express();
  }

  level--;
  cout << psp() << "exit <assignment>" << endl; // lets us know when we leave assignment
  
}

void compound() // compund statement 
{
  if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
  {
    if (nextToken != TOK_BEGIN)
    {
      throw "17: 'BEGIN' expected";
    }

    output("BEGIN");
    nextToken = yylex();
  }

  cout << psp() << "enter <compound_stmt>" << endl; // lets us know when we enter compound
  level++;

  while (nextToken == TOK_WRITE || nextToken == TOK_IDENT || nextToken == TOK_END || nextToken == TOK_SEMICOLON || nextToken == TOK_READ || nextToken == TOK_IF || nextToken == TOK_WHILE)
  {
    if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
    {
      output("STATEMENT");
      nextToken = yylex();
      write();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word and goes to assignment
    {
      output("STATEMENT");
      assignment();
    }

    if (nextToken == TOK_END) // looks for the end token and outputs and grabs next word, exit the compund and break loop
    {
      if (nextToken != TOK_END)
      {
        throw "13: 'END' expected";
      }

      --level;
      output("END");
      cout << psp() << "exit <compound_stmt>" << endl;

      nextToken = yylex();
      break;
    } 

    if (nextToken == TOK_IF) // looks for the if token and outputs and grabs next word and goes to if statement
    {
      output("STATEMENT");
      nextToken = yylex();
      ifstatement();
    }
  

    if (nextToken == TOK_READ) // looks for the begin token and outputs and grabs next word and goes to read
    {
      output("STATEMENT");
      nextToken = yylex();
      read();
    }



    if (nextToken == TOK_SEMICOLON) // looks for the semicolon token and outputs and grabs next word
    {
      if (nextToken != TOK_SEMICOLON)
      {
        throw "14: ';' expected";
      }

      output("SEMICOLON");
      nextToken = yylex();
    }

    if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while statement
    {
      output("STATEMENT");
      nextToken = yylex();
      whilestatement();
    }
  } 
}

void ifstatement()
{
  cout << psp() << "enter <if>" << endl; // lets us know when we enter if 
  level++;

  if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
  {
    express();
  }

  while (nextToken == TOK_THEN || nextToken == TOK_ELSE) 
  {
    if (nextToken == TOK_THEN) // looks for the then token and outputs and grabs next word
    {
      if (nextToken != TOK_THEN)
      {
        throw "17: 'THEN' expected";
      }

      output("THEN");
      nextToken = yylex();

      if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
      {
        output("STATEMENT");
        nextToken = yylex();
        write();
      }

      if (nextToken == TOK_READ) // looks for the read token and outputs and grabs next word and goes to read
      {
        output("STATEMENT");
        nextToken = yylex();
        read();
      }

      if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while
      {
        output("STATEMENT");
        nextToken = yylex();
        whilestatement();
      }

      if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
      {
        if (nextToken != TOK_BEGIN)
        {
          throw "17: 'BEGIN' expected";
        }

        output("STATEMENT");
        compound();
      }
    }

    if (nextToken == TOK_ELSE) // looks for the else token and outputs and grabs next word and goes to else statement
    {
      --level;
      output("ELSE");
      nextToken = yylex();
      elsestatement();
    }
  }
  
  level--;
  cout << psp() << "exit <if>" << endl; // lets us know when we exit if 
  
}


void elsestatement() // else statement
{
  cout << psp() << "enter <else>" << endl; // lets us know when we enter else
    level++;
    
    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("STATEMENT");
      compound();
    }
    
    if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
    {
      output("STATEMENT");
      nextToken = yylex();
      write();
    }

    if (nextToken == TOK_READ) // looks for the read token and outputs and grabs next word and goes to read
    {
      output("STATEMENT");
      nextToken = yylex();
      read();
    }

    if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while
    {
      output("STATEMENT");
      nextToken = yylex();
      whilestatement();
    }

    if (nextToken == TOK_IF) // looks for the if token and outputs and grabs next word and goes to if
    {
      output("STATEMENT");
      nextToken = yylex();
      ifstatement();
    }
}


void whilestatement() // while statement
{
  cout << psp() << "enter <while>" << endl; // lets us know when we enter while
  level++;

  while (first_of_express() || nextToken == TOK_BEGIN)
  {
    if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
    {
     express();
    }

    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("STATEMENT");
      compound();
    }
  }
  
  level--;
  cout << psp() << "exit <while>" << endl; // lets us know when we exit while
  
}





void read() // read statement
{
  cout << psp() << "enter <read>" << endl; // lets us know when we enter read
  level++;

  while (nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_STRINGLIT || nextToken == TOK_CLOSEPAREN)
  {
    if (nextToken == TOK_OPENPAREN) // looks for the openparen token and outputs and grabs next word
    {
      output("OPENPAREN");
      nextToken = yylex();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
    {
      output("IDENTIFIER");
      cout << psp() << yytext << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_STRINGLIT) // looks for the stringlit token and outputs and grabs next word
    {
      output("WRITE");
      cout << psp() << TOK_STRINGLIT << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_CLOSEPAREN) // looks for the closeparen token and outputs and grabs next word
    {
      output("CLOSEPAREN");
      nextToken = yylex();
      break;
    }
  }
  
  level--;
  cout << psp() << "exit <read>" << endl; // lets us know when we exit read
  
}


void write()
{
  if (!first_of_write()) // check for write
  {
    throw "133: Illegal type of operand(s)";
  }
        
  cout << psp() << "enter <write>" << endl; // lets us know when we enter write
  level++;

  while (nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_STRINGLIT || nextToken == TOK_CLOSEPAREN) 
  {
    if (nextToken == TOK_OPENPAREN) // looks for the openparen token and outputs and grabs next word
    {
      output("OPENPAREN");
      nextToken = yylex();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
    {
      output("WRITE");
      cout << psp() << yytext << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_STRINGLIT) // looks for the stringlit token and outputs and grabs next word
    {
      output("WRITE");
      cout << psp() << yytext << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_CLOSEPAREN) // looks for the closeparen token and outputs and grabs next word
    {
      output("CLOSEPAREN");
      nextToken = yylex();
      break;
    }
  }

  level--;
  cout << psp() << "exit <write>" << endl; // lets us know when we exit write
}




void express() // expressions 
{

  if (first_of_express()) // looks for the expression token and outputs
  {
    output("EXPRESSION");
  }
  else 
  {
    throw "144: illegal type of expression";
  }

  cout << psp() << "enter <expression>" << endl; // lets us know we have entered expression
  level++;

  if (first_of_simpleexpress()) // looks for the simple expression token and goes to simple
  {
    simpleexpress();
  }


  while (nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN || nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO || nextToken == TOK_IDENT)
  {

   if (nextToken == TOK_EQUALTO) // looks for the equal to token and outputs and grabs next word and goes to simple 
    {
      output("EQUALTO");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      simpleexpress();
    }

    if (nextToken == TOK_LESSTHAN) // looks for the lessthan token and outputs and grabs next word and goes to simple 
    {
      output("LESSTHAN");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      simpleexpress();
    }

    if (nextToken == TOK_GREATERTHAN) // looks for the greaterthan token and outputs and grabs next word and goes to simple 
    {
      output("GREATERTHAN");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      simpleexpress();
    }

    if (nextToken == TOK_NOTEQUALTO) // looks for the notequalto token and outputs and grabs next word and goes to simple 
    {
      output("NOTEQUALTO");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      simpleexpress();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and throws an error 
    {
      output("IDENTIFIER");
      throw "error type 104: identifier not declared";
      break;
    }
  }

 level--;
 cout << psp() << "exit <expression>" << endl; //lets us know when we exit expression
}


void simpleexpress()
{
  if (first_of_simpleexpress()) // looks for the simple expression token and outputs
  {
    output("SIMPLE_EXP");
  }
  else 
  {
    throw "901: illegal type of simple expression";
  }

  cout << psp() << "enter <simple_exp>" << endl; // lets us know we entered simple expression
  level++;

  if (first_of_term()) // looks to see if it is a first of term
  {
    term();
  }


  


  while (nextToken == TOK_PLUS || nextToken == TOK_MINUS ||nextToken == TOK_OR)
  {
    if (nextToken == TOK_PLUS ) // looks for the plus token and outputs and grabs next word and goes to term 
    {
      output("PLUS");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      term();
    }

    if (nextToken == TOK_MINUS) // looks for the minus token and outputs and grabs next word and goes to term 
    {
      output("MINUS");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      term();
    }


    if (nextToken == TOK_OR) // looks for the or token and outputs and grabs next word and goes to term 
    {
      output("OR");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      term();
    }
  }

  level--;
  cout << psp() << "exit <simple_exp>" << endl; // lets us know that we exit simple expression
}





void term()
{
  if (first_of_term()) // makes sure that token is a term
  {
    output("TERM");
  }
  else 
  {
    throw "902: illegal type of term";
  }

  cout << psp() << "enter <term>" << endl; // lets us know that we entered term
  level++;

  if(first_of_factor()) // looks to see if its a factor 
  {
    factor();
  }
 
    

  while( nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND)
  {
    if (nextToken == TOK_MULTIPLY) // looks for the muiltply token and outputs and grabs next word and goes to factor 
    {
      output("MULTIPLY");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      if( first_of_factor() )
      {
        factor();
      }
      else
      throw "error multi";
    }
    
    if (nextToken == TOK_DIVIDE) // looks for the divide token and outputs and grabs next word and goes to factor 
    {
      output("DIVIDE");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      if( first_of_factor())
      {
        factor();
      }
      else
      {
        throw "error divde";
      }
    }

    if (nextToken == TOK_AND) // looks for the and token and outputs and grabs next word and goes to factor 
    {
      output("AND");
      nextToken = yylex();
      if( first_of_factor())
      {
        factor();  
      }
      else
      {
        throw "error and";
      }
      
    }
  }

  level--;
  cout << psp() << "exit <term>" << endl; // lets us know when we exit term
}




void factor()
{
  if (first_of_factor()) // outputs if its a factor
  {
    output("FACTOR");
  }
    else 
  {
    throw "902: illegal type of factor";
  }

  cout << psp() << "enter <factor>" << endl; // lets us know when we entered factor
  level++;


  string text3; // to find the variables 

  switch (nextToken)
  {
    case TOK_IDENT:   // looks for the iden token and outputs and grabs next word and makes sure it has been declared 
    
      output("IDENTIFIER");
      cout << psp() << yytext << endl;
      text3 = strdup(yytext);

      if (symbolTable.find(text3) == symbolTable.end())
      {
        throw "104: identifier not declared";
      }
      
      nextToken = yylex();
      break;
    
    case TOK_INTLIT: // looks for the intlit token and outputs and grabs next word

      output("INTLIT");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      break;
    

    case TOK_FLOATLIT: // looks for the floatlit token and outputs and grabs next word
    
      output("FLOATLIT");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      break;

    case TOK_OPENPAREN: // looks for the openparen token and outputs and grabs next word and goes to express
    
    if (nextToken == TOK_OPENPAREN)
    {
       output("OPENPAREN");
       cout << psp() << yytext << endl;
      nextToken = yylex();
    }
    else 
    {
      throw "9: '(' expected";
    }
   

    if (!first_of_express())
    {
      throw "first token not 'ID' | 'INTLIT' | '('";
    }

    express();

    if( nextToken == TOK_CLOSEPAREN ) {
      output("CLOSEPAREN");
      nextToken = yylex();
    }

    else
      throw "4: ')' expected";
    break;

    case TOK_NOT: // looks for the not token and outputs and grabs next word

      output("NOT");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      factor();
      break;

    case TOK_MINUS: // looks for the minus token and outputs and grabs next word

      output("MINUS");
      cout << psp() << yytext << endl;
      nextToken = yylex();
      factor();
      break;
  }

 level--;
 cout << psp() << "exit <factor>" << endl; // lets us know when we exited factor
}







bool first_of_program(void) 
{
    
    return nextToken == TOK_PROGRAM || nextToken == TOK_IDENT || nextToken == TOK_SEMICOLON || nextToken == TOK_BEGIN;
}



bool first_of_express(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_STRINGLIT;  
}



bool first_of_write(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_STRINGLIT;  
}

bool first_of_simpleexpress(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS;  
}

bool first_of_term(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS;  
}

bool first_of_factor(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS;  
}