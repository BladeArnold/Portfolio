//**************************************************************************
 
// Replace with appropriate header comment......

//**************************************************************************
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include "lexer.h"
#include "parser.h"
#include "parse_tree_nodes.h"


using namespace std;

int nextToken = 0;            // hold nextToken returned by lex
int count = 1;
// Which tree level are we currently in?  
static int level = 0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
set<string> symbolTable; // Symbol Table
extern set<string> symbolTable;
set<string>::iterator it;
//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);
bool first_of_block(void);
bool first_of_statement(void);

bool first_of_express(void);
bool first_of_simpleexpress(void);
bool first_of_term(void);
bool first_of_factor(void);

bool first_of_assgin(void);
bool first_of_compound(void);
bool first_of_if(void);
bool first_of_while(void);
bool first_of_read(void);
bool first_of_write(void);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
ProgramNode* program() 
{
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    if (nextToken == TOK_PROGRAM) // looks for the program token and outputs and grabs next word
    {
      output("PROGRAM");
      nextToken = yylex();
    }
    
    cout << psp() << "enter <program>" << endl; // lets us know when we enter program and adds a level to output
    ProgramNode* newProgramNode = new ProgramNode(level);
    ++level;
    
    
    while (first_of_program()) 
    {
    if (nextToken == TOK_IDENT)  // looks for the iden token and outputs and grabs next word
    {
      output("IDENTIFIER");
      newProgramNode->restBlockOps.push_back(nextToken);
      nextToken = yylex();
    }

    if (nextToken == TOK_SEMICOLON) // looks for the semicolon token and outputs and grabs next word
    {
      if (nextToken != TOK_SEMICOLON)
      {
        throw "14: ';' expected";
      }

      output("SEMICOLON");
      newProgramNode->restBlockOps.push_back(nextToken);
      nextToken = yylex();
    } 

    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("BLOCK");
      newProgramNode->restBlockOps.push_back(nextToken);
      newProgramNode->firstBlock = block();
      break;
    }

    if (nextToken == TOK_VAR) // looks for the VAR token and outputs and grabs next word
    {
      output("BLOCK");
      newProgramNode->restBlockOps.push_back(nextToken);
      nextToken = yylex();
      newProgramNode->firstBlock = block();
      break;
    }

    else 
    {
      throw "2: identifier expected";
    }
    
    }
    
    

    --level;
    cout << psp() << "exit <program>" << endl; // lets us know when we exit the program 
    return newProgramNode;
}


BlockNode* block()
{
  cout << psp() << "enter <block>" << endl; // lets us know when we enter block and adds a level
  BlockNode* newBlockNode = new BlockNode(level);
  level++;
  

  

  string text1; // for output
  string text2; // for output
  

    while (nextToken != TOK_BEGIN)
    {
      if (nextToken == TOK_IDENT) // looks for the iden in block and outputs it and continues down the list
      {

        text1 = strdup(yytext);
        output("IDENTIFIER");
        newBlockNode->restStatementOps.push_back(nextToken);
        nextToken = yylex();
      }

      if (nextToken == TOK_COLON) // looks for the colon token and outputs and grabs next word
      {
        if (nextToken != TOK_COLON)
        {
          throw "5: ':' colon expected";
        }

        output("COLON");
        newBlockNode->restStatementOps.push_back(nextToken);
        nextToken = yylex();
      }

      if (nextToken == TOK_REAL) // looks for the real token and outputs and grabs next word
      {
        if (nextToken != TOK_REAL)
        {
          throw "10: in type";
        }

        output("TYPE");
        newBlockNode->restStatementOps.push_back(nextToken);
        text2 = strdup(yytext);
        nextToken = yylex(); 
      }

      if (nextToken == TOK_INTEGER) // looks for the integer token and outputs and grabs next word
      {
        if (nextToken != TOK_INTEGER)
        {
          throw "10: in type";
        }

        output("TYPE");
        newBlockNode->restStatementOps.push_back(nextToken);
        text2 = strdup(yytext);
        nextToken = yylex();
      }

      if (nextToken == TOK_SEMICOLON) // looks for the semicolon token, outputs the name and type, then inserts variable, then grabs next
      {
        if (nextToken != TOK_SEMICOLON)
        {
          throw "14: ';' expected";
        }

        output("SEMICOLON");
        newBlockNode->restStatementOps.push_back(nextToken);
        
        cout << psp() << "-- idName: |" << text1 << "| idType: |" << text2 << "| --" << endl;

        if (symbolTable.find(text1) != symbolTable.end())
        {
            throw "101: identifier declared twice";
        }

        symbolTable.insert(text1);
        nextToken = yylex();
      }
      else
      {
        block();
        break;
      }
      
    }

    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }
      output("BEGIN");
      newBlockNode->restStatementOps.push_back(nextToken);
      nextToken = yylex();
      newBlockNode->firstStatement = compound();
    } 

    level--;
    cout << psp() << "exit <block>" << endl; // lets us know when we leave block
    return newBlockNode;
  
}


AssginNode* assignment() // for assignment statment
{
  cout << psp() << "enter <assignment>" << endl; // lets us know when we enter assignment
  AssginNode* newAssginNode = new AssginNode(level);
  level++;

  
  
  
  if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
  {
    output("IDENTIFIER");
    newAssginNode->id = new string (yytext);
    cout << psp() << yytext << endl;
    nextToken = yylex();
  }

  if (nextToken == TOK_ASSIGN) // looks for the assign token and outputs and grabs next word
  {
    if (nextToken != TOK_ASSIGN)
    {
      throw "17: ':=' expected";
    }

    output("ASSIGN");
    nextToken = yylex();
  }

  if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
  {
    newAssginNode->expr1Ptr = express();
  }

  level--;
  cout << psp() << "exit <assignment>" << endl; // lets us know when we leave assignment
  return newAssginNode;
}


CompoundNode* compound() // compund statement 
{
  if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word
  {
    if (nextToken != TOK_BEGIN)
    {
      throw "17: 'BEGIN' expected";
    }

    output("BEGIN");
    nextToken = yylex();
  }

  vector<StatementNode*> statement;

  
  
  cout << psp() << "enter <compound_stmt>" << endl; // lets us know when we enter compound
  level++;
  

  while (nextToken == TOK_WRITE || nextToken == TOK_IDENT || nextToken == TOK_END || nextToken == TOK_SEMICOLON || nextToken == TOK_READ || nextToken == TOK_IF || nextToken == TOK_WHILE)
  {
    if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
    {
      output("STATEMENT");
      nextToken = yylex();
      statement.push_back(write());
    }

    else if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word and goes to assignment
    {
      output("STATEMENT");
      statement.push_back(assignment());
    }

    else if (nextToken == TOK_END) // looks for the end token and outputs and grabs next word, exit the compund and break loop
    {
      if (nextToken != TOK_END)
      {
        throw "13: 'END' expected";
      }

      --level;
      output("END");
      cout << psp() << "exit <compound_stmt>" << endl;

      nextToken = yylex();
      break;
    } 

    else if (nextToken == TOK_IF) // looks for the if token and outputs and grabs next word and goes to if statement
    {
      output("STATEMENT");
      nextToken = yylex();
      statement.push_back(ifstatement());
    }
  

    else if (nextToken == TOK_READ) // looks for the begin token and outputs and grabs next word and goes to read
    {
      output("STATEMENT");
      nextToken = yylex();
      statement.push_back(read());
    }



    else if (nextToken == TOK_SEMICOLON) // looks for the semicolon token and outputs and grabs next word
    {
      if (nextToken != TOK_SEMICOLON)
      {
        throw "14: ';' expected";
      }

      output("SEMICOLON");
      nextToken = yylex();
    }

    else if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while statement
    {
      output("STATEMENT");
      nextToken = yylex();
      statement.push_back(whilestatement());
    }
  } 
  CompoundNode* newCompoundNode = new CompoundNode(level, statement);
  return newCompoundNode;
}


IfNode* ifstatement()
{
  cout << psp() << "enter <if>" << endl; // lets us know when we enter if 
  IfNode* newIfNode = new IfNode(level);
  level++;

  if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
  {
    newIfNode->exprPtr = express();
  }

  while (nextToken == TOK_THEN || nextToken == TOK_ELSE) 
  {
    if (nextToken == TOK_THEN) // looks for the then token and outputs and grabs next word
    {
      if (nextToken != TOK_THEN)
      {
        throw "17: 'THEN' expected";
      }

      output("THEN");
      nextToken = yylex();

      if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
      {
        output("STATEMENT");
        nextToken = yylex();
        newIfNode->writePtr = write();
      }

      if (nextToken == TOK_READ) // looks for the read token and outputs and grabs next word and goes to read
      {
        output("STATEMENT");
        nextToken = yylex();
        read();
      }

      if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while
      {
        output("STATEMENT");
        nextToken = yylex();
        whilestatement();
      }

      if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
      {
        if (nextToken != TOK_BEGIN)
        {
          throw "17: 'BEGIN' expected";
        }

        output("STATEMENT");
        newIfNode->cmpPtr = compound();
      }
    }

    if (nextToken == TOK_ELSE) // looks for the else token and outputs and grabs next word and goes to else statement
    {
      --level;
      output("ELSE");
      nextToken = yylex();
      
    cout << psp() << "enter <else>" << endl; // lets us know when we enter else
    level++;
    
    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("STATEMENT");
      newIfNode->cmp2Ptr = compound();
    }
    
    if (nextToken == TOK_WRITE) // looks for the write token and outputs and grabs next word and goes to write
    {
      output("STATEMENT");
      nextToken = yylex();
      newIfNode->write2Ptr = write();
    }

    if (nextToken == TOK_READ) // looks for the read token and outputs and grabs next word and goes to read
    {
      output("STATEMENT");
      nextToken = yylex();
      read();
    }

    if (nextToken == TOK_WHILE) // looks for the while token and outputs and grabs next word and goes to while
    {
      output("STATEMENT");
      nextToken = yylex();
      whilestatement();
    }

    if (nextToken == TOK_IF) // looks for the if token and outputs and grabs next word and goes to if
    {
      output("STATEMENT");
      nextToken = yylex();
      newIfNode->ifPtr = ifstatement();
    }
    if (nextToken == TOK_IDENT)
    {
      output("STATEMENT");
      newIfNode->assignPtr = assignment();
    }
    }
  }
  
  level--;
  cout << psp() << "exit <if>" << endl; // lets us know when we exit if
  return newIfNode;
  
}


//IfNode* elsestatement() // else statement


WhileNode* whilestatement() // while statement
{
  cout << psp() << "enter <while>" << endl; // lets us know when we enter while
  WhileNode* newWhileNode = new WhileNode(level);
  level++;

    if (first_of_express()) // looks for the expression tokens and outputs and grabs next word
    {
     newWhileNode->exprPtr = express();
    }

  while (nextToken == TOK_BEGIN || nextToken == TOK_IDENT)
  {
    if (nextToken == TOK_IDENT) // looks for the begin token and outputs and grabs next word and goes to compound
    {

      output("STATEMENT");
      newWhileNode->assignPtr = assignment();
    }


    if (nextToken == TOK_BEGIN) // looks for the begin token and outputs and grabs next word and goes to compound
    {
      if (nextToken != TOK_BEGIN)
      {
        throw "17: 'BEGIN' expected";
      }

      output("STATEMENT");
      newWhileNode->cmpPtr = compound();
    }
  }
  
  level--;
  cout << psp() << "exit <while>" << endl; // lets us know when we exit while
  return newWhileNode;
}


ReadNode* read() // read statement
{
  cout << psp() << "enter <read>" << endl; // lets us know when we enter read
  ReadNode* newReadNode = new ReadNode(level);
  level++;


  

  while (nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_STRINGLIT || nextToken == TOK_CLOSEPAREN)
  {
    if (nextToken == TOK_OPENPAREN) // looks for the openparen token and outputs and grabs next word
    {
      output("OPENPAREN");
      nextToken = yylex();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
    {
      output("IDENTIFIER");
      newReadNode->id = new string (yytext);
      cout << psp() << yytext << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_STRINGLIT) // looks for the stringlit token and outputs and grabs next word
    {
      output("WRITE");
      newReadNode->id = new string (yytext);
      cout << psp() << TOK_STRINGLIT << endl;
      nextToken = yylex();
    }

    if (nextToken == TOK_CLOSEPAREN) // looks for the closeparen token and outputs and grabs next word
    {
      output("CLOSEPAREN");
      nextToken = yylex();
      break;
    }
  }
  
  level--;
  cout << psp() << "exit <read>" << endl; // lets us know when we exit read
  return newReadNode;
}


WriteNode* write()
{
  if (!first_of_write()) // check for write
  {
    throw "133: Illegal type of operand(s)";
  }

        
  cout << psp() << "enter <write>" << endl; // lets us know when we enter write
  level++;

  string* ident;

  while (nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_STRINGLIT || nextToken == TOK_CLOSEPAREN) 
  {
    if (nextToken == TOK_OPENPAREN) // looks for the openparen token and outputs and grabs next word
    {
      output("OPENPAREN");
      nextToken = yylex();
    }

    if (nextToken == TOK_IDENT) // looks for the iden token and outputs and grabs next word
    {
      output("WRITE");
      cout << psp() << yytext << endl;
      ident = new string(yytext);
      nextToken = yylex();
    }

    if (nextToken == TOK_STRINGLIT) // looks for the stringlit token and outputs and grabs next word
    {
      output("WRITE");
      cout << psp() << yytext << endl;
      ident = new string(yytext);
      nextToken = yylex();
    }

    if (nextToken == TOK_CLOSEPAREN) // looks for the closeparen token and outputs and grabs next word
    {
      output("CLOSEPAREN");
      nextToken = yylex();
      break;
    }
  }

  level--;
  cout << psp() << "exit <write>" << endl; // lets us know when we exit write
  WriteNode* newWriteNode = new WriteNode(level, ident);
  return newWriteNode;
}




ExprNode* express() // expressions 
{

  if (first_of_express()) // looks for the expression token and outputs
  {
    output("EXPRESSION");
  }
  else 
  {
    throw "144: illegal type of expression";
  }

  cout << psp() << "enter <expression>" << endl; // lets us know we have entered expression
  ExprNode* newExprNode = new ExprNode(level);
  level++;
  

  if (first_of_simpleexpress()) // looks for the simple expression token and goes to simple
  {
    newExprNode->firstSimple = simpleexpress();
  }


  while (nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN || nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO)
  {

   if (nextToken == TOK_EQUALTO) // looks for the equal to token and outputs and grabs next word and goes to simple 
    {
      output("EQUALTO");
      cout << psp() << yytext << endl;
      newExprNode->restSimpleOps.push_back(nextToken);
      nextToken = yylex();
      newExprNode->restSimple.push_back(simpleexpress());
    }

    if (nextToken == TOK_LESSTHAN) // looks for the lessthan token and outputs and grabs next word and goes to simple 
    {
      output("LESSTHAN");
      cout << psp() << yytext << endl;
      newExprNode->restSimpleOps.push_back(nextToken);
      nextToken = yylex();
      newExprNode->restSimple.push_back(simpleexpress());
    }

    if (nextToken == TOK_GREATERTHAN) // looks for the greaterthan token and outputs and grabs next word and goes to simple 
    {
      output("GREATERTHAN");
      cout << psp() << yytext << endl;
      newExprNode->restSimpleOps.push_back(nextToken);
      nextToken = yylex();
      newExprNode->restSimple.push_back(simpleexpress());
    }

    if (nextToken == TOK_NOTEQUALTO) // looks for the notequalto token and outputs and grabs next word and goes to simple 
    {
      output("NOTEQUALTO");
      cout << psp() << yytext << endl;
      newExprNode->restSimpleOps.push_back(nextToken);
      nextToken = yylex();
      newExprNode->restSimple.push_back(simpleexpress());
    }

  }

 level--;
 cout << psp() << "exit <expression>" << endl; //lets us know when we exit expression
 return newExprNode;

}


SimpleNode* simpleexpress()
{
  if (first_of_simpleexpress()) // looks for the simple expression token and outputs
  {
    output("SIMPLE_EXP");
  }
  else 
  {
    throw "901: illegal type of simple expression";
  }

  cout << psp() << "enter <simple_exp>" << endl; // lets us know we entered simple expression
  SimpleNode* newSimpleNode = new SimpleNode(level);
  level++;
  

  if (first_of_term()) // looks to see if it is a first of term
  {
    newSimpleNode->firstTerm = term();
  }


  


  while (nextToken == TOK_PLUS || nextToken == TOK_MINUS ||nextToken == TOK_OR)
  {
    if (nextToken == TOK_PLUS ) // looks for the plus token and outputs and grabs next word and goes to term 
    {
      output("PLUS");
      cout << psp() << yytext << endl;
      newSimpleNode->restTermOps.push_back(nextToken);
      nextToken = yylex();
      newSimpleNode->restTerms.push_back(term());
    }

    if (nextToken == TOK_MINUS) // looks for the minus token and outputs and grabs next word and goes to term 
    {
      output("MINUS");
      cout << psp() << yytext << endl;
      newSimpleNode->restTermOps.push_back(nextToken);
      nextToken = yylex();
      newSimpleNode->restTerms.push_back(term());
    }


    if (nextToken == TOK_OR) // looks for the or token and outputs and grabs next word and goes to term 
    {
      output("OR");
      cout << psp() << yytext << endl;
      newSimpleNode->restTermOps.push_back(nextToken);
      nextToken = yylex();
      newSimpleNode->restTerms.push_back(term());
    }
  }

  level--;
  cout << psp() << "exit <simple_exp>" << endl; // lets us know that we exit simple expression
  return newSimpleNode;
}





TermNode* term()
{
  if (first_of_term()) // makes sure that token is a term
  {
    output("TERM");
  }
  else 
  {
    throw "902: illegal type of term";
  }

  cout << psp() << "enter <term>" << endl; // lets us know that we entered term
  TermNode* newTermNode = new TermNode(level);
  level++;

  if(first_of_factor()) // looks to see if its a factor 
  {
    newTermNode->firstFactor = factor();
  }
 
    

  while( nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND)
  {
    if (nextToken == TOK_MULTIPLY) // looks for the muiltply token and outputs and grabs next word and goes to factor 
    {
      output("MULTIPLY");
      cout << psp() << yytext << endl;
      newTermNode->restFactorOps.push_back(nextToken);
      nextToken = yylex();
      if( first_of_factor() )
      {
        newTermNode->restFactors.push_back(factor());
      }
      else
      throw "error multi";
    }
    
    if (nextToken == TOK_DIVIDE) // looks for the divide token and outputs and grabs next word and goes to factor 
    {
      output("DIVIDE");
      cout << psp() << yytext << endl;
      newTermNode->restFactorOps.push_back(nextToken);
      nextToken = yylex();
      if( first_of_factor())
      {
        newTermNode->restFactors.push_back(factor());
      }
      else
      {
        throw "error divde";
      }
    }

    if (nextToken == TOK_AND) // looks for the and token and outputs and grabs next word and goes to factor 
    {
      output("AND");
      nextToken = yylex();
      if( first_of_factor())
      {
        newTermNode->restFactors.push_back(factor());
      }
      else
      {
        throw "error and";
      }
      
    }
  }

  level--;
  cout << psp() << "exit <term>" << endl; // lets us know when we exit term
  return newTermNode;
}




FactorNode* factor()
{
  if (first_of_factor()) // outputs if its a factor
  {
    output("FACTOR");
  }
    else 
  {
    throw "902: illegal type of factor";
  }

  cout << psp() << "enter <factor>" << endl; // lets us know when we entered factor
  FactorNode* newFactorNode = nullptr;
  level++;
  

  string text3; // to find the variables 

  switch (nextToken)
  {
    case TOK_IDENT:   // looks for the iden token and outputs and grabs next word and makes sure it has been declared 
    
      output("IDENTIFIER");
      cout << psp() << yytext << endl;
      text3 = strdup(yytext);

      if (symbolTable.find(text3) == symbolTable.end())
      {
       throw "104: identifier not declared";
      }
      //level--;
      newFactorNode = new IdNode(level, string(yytext));
      //level++;
      nextToken = yylex();
      break;
    
    case TOK_INTLIT: // looks for the intlit token and outputs and grabs next word

      output("INTLIT");
      cout << psp() << yytext << endl;
      //level--;
      newFactorNode = new IntLitNode(level, atoi(yytext));
      //level++;
      nextToken = yylex();
      break;
    

    case TOK_FLOATLIT: // looks for the floatlit token and outputs and grabs next word
    
      output("FLOATLIT");
      cout << psp() << yytext << endl;
      //level--;
      newFactorNode = new FloatLitNode(level, stof(yytext));
      //level++;
      nextToken = yylex();
      break;

    case TOK_OPENPAREN: // looks for the openparen token and outputs and grabs next word and goes to express
    
    if (nextToken == TOK_OPENPAREN)
    {
       output("OPENPAREN");
       cout << psp() << yytext << endl;
      nextToken = yylex();
    }
    else 
    {
      throw "9: '(' expected";
    }
   

    if (!first_of_express())
    {
      throw "first token not 'ID' | 'INTLIT' | '('";
    }
    newFactorNode = new NestedExprNode(level, express());

    if( nextToken == TOK_CLOSEPAREN ) {
      output("CLOSEPAREN");
      nextToken = yylex();
    }

    else
      throw "4: ')' expected";
    break;

    case TOK_NOT: // looks for the not token and outputs and grabs next word

      output("NOT");
      cout << psp() << yytext << endl;
      // level--;
      // //newFactorNode = new NotNode(level, string(yytext));
      // level++;
      nextToken = yylex();
      newFactorNode = new NestedFactorNode(level, factor());
      
      break;

    case TOK_MINUS: // looks for the minus token and outputs and grabs next word

      output("MINUS");
      cout << psp() << yytext << endl;
      //newFactorNode = new MinusNode(level, string(yytext));
      nextToken = yylex();
      newFactorNode = new MinusNode(level, factor());
      break;
  }

 level--;
 cout << psp() << "exit <factor>" << endl; // lets us know when we exited factor

 return newFactorNode;
}









bool first_of_program(void) 
{
    
    return nextToken == TOK_PROGRAM || nextToken == TOK_IDENT || nextToken == TOK_SEMICOLON || nextToken == TOK_BEGIN;
}



bool first_of_express(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_STRINGLIT || nextToken == TOK_NOT || nextToken == TOK_MINUS;  
}



bool first_of_write(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_STRINGLIT || nextToken == TOK_NOT;  
}

bool first_of_simpleexpress(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS || nextToken == TOK_NOT;  
}

bool first_of_term(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS || nextToken == TOK_NOT;  
}

bool first_of_factor(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_INTLIT || nextToken == TOK_OPENPAREN || nextToken == TOK_FLOATLIT || nextToken == TOK_MINUS || nextToken == TOK_NOT;  
}